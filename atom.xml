<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://x956606865.github.io/conceal-name/</id>
    <title>常名斋</title>
    <updated>2019-11-22T03:45:55.723Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://x956606865.github.io/conceal-name/"/>
    <link rel="self" href="https://x956606865.github.io/conceal-name//atom.xml"/>
    <subtitle>万物有名，常名斋，藏名斋。</subtitle>
    <logo>https://x956606865.github.io/conceal-name//images/avatar.png</logo>
    <icon>https://x956606865.github.io/conceal-name//favicon.ico</icon>
    <rights>All rights reserved 2019, 常名斋</rights>
    <entry>
        <title type="html"><![CDATA[周报 2019.11.18-2019.11.22]]></title>
        <id>https://x956606865.github.io/conceal-name//post/zhou-bao-20191118-20191122</id>
        <link href="https://x956606865.github.io/conceal-name//post/zhou-bao-20191118-20191122">
        </link>
        <updated>2019-11-22T03:30:14.000Z</updated>
        <summary type="html"><![CDATA[<p><em>(封面图作者: nys)</em></p>
]]></summary>
        <content type="html"><![CDATA[<p><em>(封面图作者: nys)</em></p>
<!-- more -->
<h2 id="文章">文章</h2>
<ul>
<li>
<p><a href="https://pomb.us/build-your-own-react/">从零开始写一个 React 框架</a></p>
<p>挺不错的了解react的文章</p>
</li>
<li>
<p><a href="https://github.com/ruanyf/document-style-guide/blob/master/docs/text.md">中文文章写作规范</a></p>
<p>阮一峰大佬写的关于中文文章的写作规范</p>
</li>
<li>
<p><a href="https://reactjs.org/docs/concurrent-mode-intro.html#what-is-concurrent-mode">Introducing Concurrent Mode</a></p>
<p>介绍了React仍处于实验室阶段的新特性 &quot;并行渲染&quot;，相关的使用场景以及和传统方式相比的差异。如果能投入生产环境，应该会对当前很多react的场景带来改变。 (<strong>非常值得关注</strong>)  (英文)</p>
</li>
<li>
<p><a href="https://juejin.im/post/5dd39c866fb9a0200f053b0f">如何监听 DOM 变化</a></p>
<p>文章讲的很浅，但是其中提到的Mutation Observer这个特性很重要，如果要自己手写一个小框架练手，或者写网页工具，那么这个就很值得了解了</p>
</li>
<li>
<p><a href="https://github.com/drduh/YubiKey-Guide#purchase-yubikey">drduh/YubiKey-Guide</a></p>
<p>YubiKey 是一种目前较为流行的硬件密钥，这个仓库是网友写的使用手册（英文）(PS: 之前也打算过买一个试试，不过在amazon上价格还是有点稍贵，也有一些兼容方面的硬伤)</p>
</li>
<li>
<p><a href="https://www.manifold.co/blog/graphql-vs-rest-whats-the-advantage">GraphQL vs. REST: What's The Advantage?</a></p>
<p>对比介绍GraphQL比REST好在哪里。不得不说GraphQL前景很高，不过在国内没有那么火 (英文)</p>
</li>
<li>
<p><a href="https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/">Deep dive: How do React hooks really work?</a></p>
<p>介绍了React Hook的原理，然后介绍了怎么简单的自己实现一个React Hook功能 (英文)</p>
</li>
<li>
<p><a href="https://chriskiehl.com/article/gooey-as-a-universal-frontend">Using Gooey as a Universal Frontend for any Language or CLI Application</a></p>
<p>介绍了怎么用Gooey这个库通过简单的描述，自动为python命令行工具生成gui页面，十分给力  (英文)</p>
</li>
</ul>
<h2 id="资源">资源</h2>
<ul>
<li>
<p><a href="https://free-for.dev/#/?id=free-fordev">free-for.dev</a></p>
<p>该仓库收集各种可以免费使用的（或有免费层的）互联网服务</p>
</li>
<li>
<p><a href="http://t.cn/Air2Rw5Y">FCC 2019成都全栈大会</a></p>
<p>2019年成都全栈大会PPT整理，不少值得关注的东西</p>
</li>
</ul>
<h2 id="工具">工具</h2>
<ul>
<li>
<p><a href="https://github.com/ngbdf/redis-manager">Redis Manager</a></p>
<p>作为一个 Redis 一站式管理平台，它支持 Redis 集群的管理、监控、创建以及告警等功能。它大大降低了 Redis 集群的运维成本，能做到对集群的实时监控，在 Redis 出现问题是进行准确的故障排查，亦或者通过分析历史数据还原 Redis 故障时的场景，同时还支持自定义监控规则的告警功能，让你随时了解 Redis 的运行状况。</p>
<p>配图见附录2</p>
</li>
<li>
<p><a href="https://github.com/yinxin630/fiora">fiora</a></p>
<p>一个功能丰富、支持多端的在线聊天室。它界面小清新，支持基本的聊天功能的同时还有好玩的消息朗读功能。项目上基于 TypeScript + React 16.9 代码逻辑清晰、注释较为完善，适合用来学习 node.js、 TypeScript、React 等技术</p>
<p>配图见附录2</p>
</li>
</ul>
<h2 id="js-库">JS 库</h2>
<ul>
<li>
<p><a href="https://github.com/Mckinsey666/chart-race-react">Mckinsey666/chart-race-react</a></p>
<p>一个简单易用的 Bar Chart Race（长条图赛跑动画） React 组件：chart-race-react</p>
</li>
<li>
<p><a href="https://github.com/alibaba/form-render">form-render</a></p>
<p>阿里内部表单生成器开源，基于schema生成表单</p>
</li>
<li>
<p><a href="douglasjunior/react-native-keyboard-manager">react-native-keyboard-manager</a></p>
<p>好用的RN的键盘防遮挡库，同时还会为各类原生键盘添加Done按钮，非常实用 (<strong>来自Joe的投稿</strong>)</p>
</li>
<li>
<p><a href="https://github.com/HarryChen0506/react-markdown-editor-lite">HarryChen0506/react-markdown-editor-lite</a></p>
<p>一款轻量的基于React的markdown编辑器</p>
</li>
<li>
<p><a href="https://github.com/sindresorhus/globby">sindresorhus/globby</a></p>
<p>nodejs自带的glob库的扩展库，写命令行程序的时候会非常有用。如果你想批量匹配一个目录下的满足某些条件的文件并且惰性加载，这个库就很实用 (ps: 例如egg这类库，在config目录下写的所有js都会被加载到全局实例的属性中，就是靠这种方式的)</p>
</li>
<li>
<p><a href="https://github.com/zeit/swr">swr</a></p>
<p>一个React Hook工具，传入一个service函数作为驱动，可以用swr来依靠react hook的方式管理service的数据拉取操作，同时管理token的刷新和出错自动重试之类的操作</p>
</li>
<li>
<p><a href="https://www.npmjs.com/package/yargs">yargs</a></p>
<p>算是命令行工具commander的竞品，但是对多级子命令的支持更好  (代码示例见附录一)</p>
</li>
<li>
<p><a href="https://gun.eco/docs/Introduction">GunDB</a></p>
<p>一个离线优先的去中心化数据库，数据存储在浏览器端，依靠一个轻量的服务器来做同步通讯。十分适合做端到端加密的应用以及一些比如AR之类的离线优先的应用</p>
</li>
</ul>
<h2 id="附录1-部分代码演示">附录1 部分代码演示</h2>
<ul>
<li>
<p>yargs</p>
<pre><code class="language-javascript">#!/usr/bin/env node
require('yargs')
  .command(['start [app]', 'run', 'up'], 'Start up an app', {}, (argv) =&gt; {
    console.log('starting up the', argv.app || 'default', 'app')
  })
  .command({
    command: 'configure &lt;key&gt; [value]',
    aliases: ['config', 'cfg'],
    desc: 'Set a config variable',
    builder: (yargs) =&gt; yargs.default('value', 'true'),
    handler: (argv) =&gt; {
      console.log(`setting ${argv.key} to ${argv.value}`)
    }
  })
  .demandCommand()
  .help()
  .wrap(72)
  .argv
</code></pre>
</li>
</ul>
<h2 id="附录2-部分截图演示">附录2 部分截图演示</h2>
<ul>
<li>
<p>Redis Manager</p>
<figure data-type="image" tabindex="1"><img src="https://github.com/ngbdf/redis-manager/raw/master/documents/images/index.png" alt=""></figure>
</li>
<li>
<p>Mckinsey666/chart-race-react</p>
<figure data-type="image" tabindex="2"><img src="https://hellogithub.cn-bj.ufileos.com/hellogithub/43/img/chart-race-react.gif" alt=""></figure>
</li>
<li>
<p>fiora</p>
<figure data-type="image" tabindex="3"><img src="https://hellogithub.cn-bj.ufileos.com/hellogithub/43/img/fiora.png" alt=""></figure>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[周报 2019.11.11-2019.11.15]]></title>
        <id>https://x956606865.github.io/conceal-name//post/zhou-bao-20191111-20191115</id>
        <link href="https://x956606865.github.io/conceal-name//post/zhou-bao-20191111-20191115">
        </link>
        <updated>2019-11-15T02:48:04.000Z</updated>
        <summary type="html"><![CDATA[<p><em>(封面图作者: 香川悠作)</em></p>
]]></summary>
        <content type="html"><![CDATA[<p><em>(封面图作者: 香川悠作)</em></p>
<!-- more -->
<h2 id="文章">文章</h2>
<ul>
<li>
<p><a href="https://vasanthk.gitbooks.io/react-bits/">React Bits</a></p>
<p>关于JSX相关小技巧的集合</p>
</li>
<li>
<p><a href="https://zellwk.com/blog/converting-callbacks-to-promises/">converting-callbacks-to-promises</a></p>
<p>将回调函数转变为promise的各种方案（英文）</p>
</li>
<li>
<p><a href="https://itnext.io/how-json-stringify-killed-my-express-server-d8d0565a1a61">how-json-stringify-killed-my-express-server</a></p>
<p>JSON.stringify为什么在服务端会大量占用CPU资源（英文）</p>
</li>
<li>
<p><a href="https://www.conventionalcommits.org/zh-cn/v1.0.0-beta.4/">约定式提交</a></p>
<p>详细介绍了commit message的通用约定规范，其对应的目的，带来的好处等等</p>
</li>
<li>
<p><a href="https://www.duyaoss.com/archives/3/">浅谈部分机场的使用感受</a></p>
<p>由于自建SSR容易被BAN，速度慢等等问题，机场（SSR as Service） 成了另一种<strong>个人用</strong>梯子的一个方案，这篇文章讲了目前的一些知名大型机场的一些优缺点以及费用等等</p>
</li>
<li>
<p><a href="https://easyai.tech/blog/59pdf-nlp-all-in-one/">「59页PDF」自然语言处理 NLP 基本概念大全（免费下载</a></p>
<p>如题</p>
</li>
<li>
<p><a href="https://juejin.im/post/5dbf749df265da4d560910b8">精读《React Conf 2019 - Day1》</a></p>
<p>React conf大会的内容总结，未来的发展方向，新的写法，新的特性等等，值得一看</p>
</li>
<li>
<p><a href="https://juejin.im/post/5d5ccdd75188255625591357">axios如何利用promise无痛刷新token(一)</a></p>
<p>在用户无感知情况下刷新token过期时间，替换token是做token状态管理的一大重点，本文主要讲了以前端判断为主的一种方案以及以后端判断为主的另一种方案，值得了解。PS: 以及后续<a href="https://juejin.im/post/5dcac7686fb9a04a9e37b595">axios如何利用promise无痛刷新token(二)</a></p>
</li>
<li>
<p><a href="https://juejin.im/post/5dc4d823f265da4d4c202d3b">V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道</a></p>
<p>对V8部分机制的介绍，文章有一点点小长，可以单纯的作为扩展知识面的一个了解。</p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/87940654">《面向传统，Serverless 进化之路》分享文字版</a></p>
<p>标标准准的基于函数云的微服务架构实践，全面函数化的微服务，可以参考思路。（PS: 没有参加今年的 JS Conf好可惜）</p>
</li>
<li>
<p><a href="https://juejin.im/post/5db4253451882556a035ae5d?utm_source=tuicool&amp;utm_medium=referral">带你手写微前端框架</a></p>
<p>微前端的代码实现方案思路，可以参考。PS：这是微前端，不是微服务。</p>
</li>
<li>
<p><a href="https://fangpenlin.com/posts/2019/10/07/elliptic-curve-cryptography-explained/">椭圆曲线加密法(英文)</a></p>
<p>基于数学的椭圆曲线加密技术，很厉害，但是没看懂.....</p>
</li>
</ul>
<h2 id="工具">工具</h2>
<ul>
<li>
<p><a href="https://github.com/b3log/solo">b3log/solo</a></p>
<p>一款小而美的博客系统，专为程序员设计，包含了一整套的成型的个人博客搭建方案和后台系统。(PS: 同时推荐个人感觉更好用的零成本的博客搭建系统 <a href="https://gridea.dev/">Gridea</a></p>
<p>示例图见附录2.</p>
</li>
<li>
<p><a href="https://github.com/mcollina/autocannon">mcollina/autocannon</a></p>
<p>知名的压力测试工具</p>
<p>示例图见附录2.</p>
</li>
<li>
<p><a href="https://crontab.guru/">crontab</a></p>
<p>在线编辑cron表达式的工具</p>
</li>
<li>
<p><a href="https://github.com/n8n-io/n8n">n8n-io/n8n</a></p>
<p>开源的个人自动化workflow工具，如果你用过zapire或者IFTTT，那这个可能是个不错的替代品</p>
<p>示例图见附录2.</p>
</li>
<li>
<p><a href="https://github.com/lra/mackup">lra/mackup</a></p>
<p>与Dropbox等网盘结合的系统配置备份工具，支持超过200多个常用的命令行APP的配置备份与意见还原。同时可以轻松的自定义自己的备份app，让换开发机或者一键导入环境变得更简单</p>
</li>
<li>
<p><a href="https://www.yinsiduanxin.com/dl/1.html">隱私小號</a></p>
<p>在线网页工具，提供大量可供收发临时短信的手机号，可以用于短信功能的实机测试</p>
</li>
<li>
<p><a href="https://github.com/imgproxy/imgproxy">imgproxy/imgproxy</a></p>
<p>Go语言写的一个图片代理服务器，支持docker部署，可以代理服务，预处理图片，包括裁剪、压缩、缩放、简单特效等等实用功能，支持图片存放在本地、S3以及google drive。<strong>值得关注</strong></p>
</li>
<li>
<p><a href="https://screendump.techulus.com/">screendump</a></p>
<p>一个在线预览目标Url在不同尺寸下显示效果的网站，虽然不能像浏览器开发者工具一样还可以操作，但是好处是方便，可以一次看到所有常用尺寸下的效果，对静态站的效果很不错。</p>
</li>
</ul>
<h2 id="js-库">JS 库</h2>
<ul>
<li>
<p><a href="https://github.com/matthewmueller/x-ray">matthewmueller/x-ray</a></p>
<p>从html中提取元素转换为json输出的类库</p>
<p>示例代码见附录1.</p>
</li>
<li>
<p><a href="https://github.com/ai/nanoid/">ai/nanoid</a></p>
<p>非常简单轻量的UUID生成器类库，基于uuid v4规范，适用于简单的环境</p>
</li>
<li>
<p><a href="https://github.com/jonschlinkert/dashify">jonschlinkert/dashify</a></p>
<p>功能简单的使用小工具库，就是把大小驼峰字符串转换为中划线分割的字符串，简单，但是有时候很实用。</p>
<p>示例代码见附录1.</p>
</li>
<li>
<p><a href="https://github.com/react-hook-form/react-hook-form/blob/master/docs/README.zh-CN.md">react-hook-form/react-hook-form</a></p>
<p>使用react-hook实现的form组件，对代码侵入性非常低，而且基于hook的写法也非常简洁，支持RN和Web，有个在线工具可以在线拖拽生成对应代码直接使用，在github上的star也非常高，<strong>十分值得关注</strong>。</p>
</li>
</ul>
<h2 id="一句话新闻">一句话新闻</h2>
<ul>
<li>Typescript 3.7版本正式发布，支持可选运算符、nullish 合并、原生的断言 assert 方法等等期待已久的新特性，值得关注。</li>
<li>10月25日，谷歌发布了一种新的搜索算法 BERT，已经用于生产环境。这种算法最大的特点，就是考虑了搜索词的语序。以前的算法只考虑每个词本身，搜索hello world与搜索world hello，结果是一样的。<a href="https://blog.google/products/search/search-language-understanding-bert/">点击查看</a></li>
<li>Github官方终于推出了手机版的github，ios版已经可以下载试玩了，安卓版似乎是审核问题，还需要稍等.<a href="https://github.com/mobile">传送门</a></li>
</ul>
<h2 id="附录1-部分代码演示">附录1 部分代码演示</h2>
<ul>
<li>
<p>matthewmueller/x-ray</p>
<pre><code class="language-javascript">var Xray = require('x-ray')
var x = Xray()

x('https://blog.ycombinator.com/', '.post', [
  {
    title: 'h1 a',
    link: '.article-title@href'
  }
])
  .paginate('.nav-previous a@href')
  .limit(3)
  .write('results.json')
</code></pre>
</li>
<li>
<p>jonschlinkert/dashify</p>
<pre><code class="language-javascript">var dashify = require('dashify');

console.log(dashify('fooBar'));
//=&gt; 'foo-bar'

console.log(dashify('fooBarBaz'));
//=&gt; 'foo-bar-baz'

console.log(dashify('foo bar'));
//=&gt; 'foo-bar'

console.log(dashify('foo barBaz'));
//=&gt; 'foo-bar-baz'

console.log(dashify('foo barBaz quux'));
//=&gt; 'foo-bar-baz-quux'

console.log(dashify('São Tomé and Príncipe'));
//=&gt; 'são-tomé-and-príncipe'
</code></pre>
</li>
</ul>
<h2 id="附录2-部分截图演示">附录2 部分截图演示</h2>
<ul>
<li>
<p>solo</p>
<ul>
<li>
<figure data-type="image" tabindex="1"><img src="https://user-images.githubusercontent.com/970828/56886176-f210a700-6aa0-11e9-894f-75eda5cf3317.png" alt=""></figure>
</li>
<li>
<figure data-type="image" tabindex="2"><img src="https://user-images.githubusercontent.com/970828/56886177-f2a93d80-6aa0-11e9-8a87-14731bdf59e7.png" alt=""></figure>
</li>
</ul>
</li>
<li>
<p>mcollina/autocannon</p>
<ul>
<li><img src="https://raw.githubusercontent.com/mcollina/autocannon/master/demo.gif" alt=""></li>
</ul>
</li>
<li>
<p>n8n-io/n8n</p>
<ul>
<li><img src="https://raw.githubusercontent.com/n8n-io/n8n/master/docs/images/n8n-screenshot.png" alt=""></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于文本密度提取网页正文]]></title>
        <id>https://x956606865.github.io/conceal-name//post/ji-yu-wen-ben-mi-du-ti-qu-wang-ye-zheng-wen</id>
        <link href="https://x956606865.github.io/conceal-name//post/ji-yu-wen-ben-mi-du-ti-qu-wang-ye-zheng-wen">
        </link>
        <updated>2019-10-11T11:17:19.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>近期看到了一篇蛮不错的论文《<a href="http://kns.cnki.net//KXReader/Detail?TIMESTAMP=637061287807268750&amp;DBCODE=CJFQ&amp;TABLEName=CJFDLAST2019&amp;FileName=GWDZ201908029&amp;RESULT=1&amp;SIGN=Ru92HQCAbOX5F3X475n1xKVQA7I%3d&amp;UID=WEEvREcwSlJHSldTTEYzVTE0ZUZRMGFJdytrZXZHWmJkaE5oc3RlMlJyMD0%3d%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;autoLogin=0">基于文本及符号密度的网页正文提取方法</a>》，因为刚好在学习Rust写hello world，想想干脆试试能不能实现这个思路吧，于是开始尝试代码实现。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>近期看到了一篇蛮不错的论文《<a href="http://kns.cnki.net//KXReader/Detail?TIMESTAMP=637061287807268750&amp;DBCODE=CJFQ&amp;TABLEName=CJFDLAST2019&amp;FileName=GWDZ201908029&amp;RESULT=1&amp;SIGN=Ru92HQCAbOX5F3X475n1xKVQA7I%3d&amp;UID=WEEvREcwSlJHSldTTEYzVTE0ZUZRMGFJdytrZXZHWmJkaE5oc3RlMlJyMD0%3d%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;autoLogin=0">基于文本及符号密度的网页正文提取方法</a>》，因为刚好在学习Rust写hello world，想想干脆试试能不能实现这个思路吧，于是开始尝试代码实现。</p>
<!-- more -->
<h2 id="思路">思路</h2>
<p>总的来说，这篇论文分析了大部分新闻网站页面，思考了其中的数学共性。虽然不同的网站，结构千变万化，但是从读者的直观印象来说，正文部分是十分明显的。打开一个新闻网页，我们总能很轻松的找出正文在哪里，而不会把广告或者页脚什么的当成正文。</p>
<p>按照这个思路走下去，我们大脑是如何识别正文的呢？首先，文本的数量必然是关键变量之一。其次就是文本的密集程度，正文的内容总是密集耦合在一起的，而不是部分在页面上方，部分在右下角这样分散排布的，正文总是会被一个“框”给包裹起来成为一个整体。对于读者来说，这个“框”是设计上的分割线，对于网页来说，这个“框”就是所有正文所公共的父级DOM节点。</p>
<p>假如我们能抽象出一个公式来模拟大脑的识别，那么我们就能像读者找出正文所在的“框”一样，找出包裹着正文的最近的DOM节点，从而精确提取出正文。</p>
<h2 id="实现">实现</h2>
<ol>
<li>
<p>DOM树生成</p>
<p>首先根据拿到的网页源代码，我们可以很简单的生成一颗DOM树，这个在不同语言都有自己的实现，可以很轻松的生成。</p>
</li>
<li>
<p>Info树的生成</p>
<p>因为我们实际需要的每个树节点的部分信息，因此，我们需要遍历DOM树，拿到每个节点的特定信息后生成一棵新的Info树。之后所有的操作都基于这颗Info树来进行。</p>
<p>p.s. 因为正文必然是在Body标签内部的，所以我们可以直接把Body标签作为新树的根节点。</p>
<p>p.p.s 同样因为我们不关心渲染与执行，所以script、form、img、style等等标签除了影响结果外毫无用处，所以新树生成的时候需要过滤掉这些节点。</p>
<p>p.p.p.s 在现代网页中，因为网页很多标签是动态生成的，所以会有大量的无内容的空标签占位，同样需要将其移除。</p>
<p>最后每个Info 树的节点大概会像这样的:</p>
<pre><code> pub struct Node {
     pub tag_num: i16, // 该节点子代tag节点数量
     pub text_length: i32, // 该节点总文本长度
     pub link_tag_num: i16, // 该节点子代中超链接tag节点数量
     pub text_tag_num: i16, // 该节点子代中文本tag节点数量
     pub punctuation_num: i16, // 该节点子代中所有文本符号数量
     pub link_tag_text_length: i16, // 该节点子代节点中超链接tag节点文本长度
     pub td: f32, // 该节点计算出的文本密度
     pub sbd:f64, // 该节点计算出的符号密度
     pub score: f64, // 该节点计算出的分数
     pub node_type: NodeTypeEnum, // 该节点的类型
     pub tag_name: String, // 标签名称
     pub text: String, // 如果是文本标签，则保存了对应的文本值
     pub children: Vec&lt;Node&gt;, // 子代节点
 }
</code></pre>
</li>
<li>
<p>计算</p>
<p>可以看出，除去基本信息，我们需要计算的就是每个节点的文本密度、符号密度以及所有节点的文本密度的标准差。然后带入公式对每个节点进行打分。</p>
<p>p.s. 具体公式以及公式推导请参考论文，这里不太适合将别人研究成果直接放在文章内。《<a href="http://kns.cnki.net//KXReader/Detail?TIMESTAMP=637061287807268750&amp;DBCODE=CJFQ&amp;TABLEName=CJFDLAST2019&amp;FileName=GWDZ201908029&amp;RESULT=1&amp;SIGN=Ru92HQCAbOX5F3X475n1xKVQA7I%3d&amp;UID=WEEvREcwSlJHSldTTEYzVTE0ZUZRMGFJdytrZXZHWmJkaE5oc3RlMlJyMD0%3d%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;autoLogin=0">基于文本及符号密度的网页正文提取方法</a>》</p>
</li>
<li>
<p>遍历</p>
<p>遍历整棵树找出分数最高的节点，就是对应的正文节点。</p>
</li>
<li>
<p>测试</p>
<p>论文中提到的新闻网差不多正确率百分之九十九左右，虽然是论文中自己提供的正确率，但是实际测试确实还没有遇到提取失败的情况。</p>
</li>
</ol>
<h2 id="进一步思考">进一步思考</h2>
<p>在基础实现后，我尝试对掘金、简书等技术文章网站进行了测试，发现效果极差，几乎没有成功的案例。</p>
<p>所以和新闻网站结构类似的文章网站为什么会失效呢？从我们之前的分析来说，应该不会因为是文章而不是新闻而产生差异啊。</p>
<p>经过对比后发现，主要原因在于掘金等这些偏技术的文章网站，文章内容主要是由MD格式的文章转换成HTML而来的，而MD特殊之处导致了公式中很多变量产生了变动.</p>
<h3 id="md的转换">MD的转换</h3>
<p>虽然从结果来看，直接写html的文章和写md格式的文章转换成html显示，这两种方式并不会有什么差别，用户也可以无感知的使用在线编辑器。</p>
<p>但是对比可以发现，因为MD的语法习惯，所以会有大量的斜体、加粗、强调、引用等等样式标记被装换成b、i、strong等等标签，而在新闻网中，这些往往是交给css处理的样式。这样就导致产生了大量的零碎的标签，降低父文本的文本密度。</p>
<p>其次，在转换中，p标签的出现次数也极低，大部分文本在转换中直接成了div的子元素，而不是被包裹在标准的p标签中。</p>
<p>对于标准html来说，正文往往就是被一大堆p标签分割的段落组成。然而在MD转换的html代码中，正文大部分被div、li、code、pre等等多种多样的标签包裹，影响打分。</p>
<h3 id="md的写作习惯">MD的写作习惯</h3>
<p>同时，因为MD语法被程序员用的最多，并且技术文章的结构特性，也导致了文章中大概率会出现非常多的有序列表和无序列表还有代码举例，所以li、ol、code、pre这几个标签分别占有了文本总长度中非常高的比例。</p>
<p>综上所述，如果按照原有计算方式计算，最后父节点的打分会非常低，而一些直接包裹文本的节点会因为文本密度非常高而分数变得异常的高。</p>
<h2 id="修改">修改</h2>
<p>针对以上情况，可以考虑做以下处理:</p>
<ul>
<li>因为div在该模型中主要担当container的角色，所以不应该直接包裹文本元素，在生成Info树的时候，如果遇到直接属于div的文本内容，应手动为其包裹一层p标签。</li>
<li>对于strong、b、i这类纯样式修饰的行内标签，可以直接移除，包裹的文本直接归并到上一级文本节点中。</li>
<li>原论文中在打分公式中计算了整颗树p标签节点的数量来作为参考变量。而在md中，应考虑将ul、code、pre等高频标签当做p标签来计数。除去渲染出来的样式，他们在整体结构中，和p标签的作用是一致的。</li>
<li>因为内容被各种标签分成了太多的小块，导致部分文本标签打分异常暴涨可能性极高，可以考虑查找最高分数的节点的时候，主动过滤掉不可能成为正文父节点的一些标签，如p、code、pre等等，找出容器类标签中分值最高的那一个节点。（ p.s. 这条才是真正可以大幅度提高正确率的操作 ）</li>
</ul>
<h2 id="结语">结语</h2>
<p>修改后的代码，对于掘金、简书等文章基本可以正确的提取正文了。（ p.s. 缺乏充足的用例测试 ）</p>
<p>最后吐槽，rust的思路真的太难受了，比起用其他语言实现，起码多花了一倍的时间在思考语法该怎么写上面Orz。</p>
<p>附上链接:</p>
<p>论文：《<a href="http://kns.cnki.net//KXReader/Detail?TIMESTAMP=637061287807268750&amp;DBCODE=CJFQ&amp;TABLEName=CJFDLAST2019&amp;FileName=GWDZ201908029&amp;RESULT=1&amp;SIGN=Ru92HQCAbOX5F3X475n1xKVQA7I%3d&amp;UID=WEEvREcwSlJHSldTTEYzVTE0ZUZRMGFJdytrZXZHWmJkaE5oc3RlMlJyMD0%3d%249A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;autoLogin=0">基于文本及符号密度的网页正文提取方法</a>》</p>
<p>我的 rust 代码例子: <a href="https://github.com/x956606865/test-extract">https://github.com/x956606865/test-extract</a></p>
<p>另一位大佬用python写的更牛逼的版本:  <a href="https://github.com/kingname/GeneralNewsExtractor">https://github.com/kingname/GeneralNewsExtractor</a></p>
<p>Link:<a href="https://www.notion.so/aj0k3r/2127bd615e034209b818875d2fcec664">https://www.notion.so/aj0k3r/2127bd615e034209b818875d2fcec664</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[译]Node v11 中定时器和微指令的新变化]]></title>
        <id>https://x956606865.github.io/conceal-name//post/yi-node-v11-zhong-ding-shi-qi-he-wei-zhi-ling-de-xin-bian-hua</id>
        <link href="https://x956606865.github.io/conceal-name//post/yi-node-v11-zhong-ding-shi-qi-he-wei-zhi-ling-de-xin-bian-hua">
        </link>
        <updated>2019-03-04T11:59:34.000Z</updated>
        <summary type="html"><![CDATA[<p>本文是我之前关于  Node.js  事件循环的系列文章的简短跟进。在之前的系列文章中，我详细讨论了Timers，setImmediate，process.nextTick，Promises等等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文是我之前关于  Node.js  事件循环的系列文章的简短跟进。在之前的系列文章中，我详细讨论了Timers，setImmediate，process.nextTick，Promises等等。</p>
<!-- more -->
<p>但是，自 Node.js  v11.0.0 起，对 setTimeout，setImmediate，process.nextTick 和Promises 的行为进行了一些重大更改。在本文中，我将讨论这些新的更改以及 Node &lt; v11.0.0 和 Node ≥ v11.0.0 之间的功能的一些比较。如果您错过了我之前关于 Node.js事件循环的任何文章，我建议您从以下链接中阅读它们然后返回此处以查看 Node v11.0.0中引入的新更改。</p>
<ul>
<li><a href="https://jsblog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810">Reactor Pattern and the Big Picture</a></li>
<li><a href="https://jsblog.insiderattack.net/timers-immediates-and-process-nexttick-nodejs-event-loop-part-2-2c53fd511bb3">Timers and Immediates</a></li>
<li><a href="https://jsblog.insiderattack.net/promises-next-ticks-and-immediates-nodejs-event-loop-part-3-9226cbe7a6aa">Promises, Next-Ticks and Immediates</a></li>
<li><a href="https://jsblog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1">Handling I/O</a></li>
<li><a href="https://jsblog.insiderattack.net/event-loop-best-practices-nodejs-event-loop-part-5-e29b2b50bfe2">Event Loop Best Practices</a></li>
</ul>
<h2 id="详解">详解</h2>
<p>如果您分别在浏览器和 Node.js 中单独运行以下代码，会得到完全相反的结果。</p>
<pre><code>setTimeout(() =&gt; console.log('timeout1'));
setTimeout(() =&gt; {
    console.log('timeout2')
    Promise.resolve().then(() =&gt; console.log('promise resolve'))
});
setTimeout(() =&gt; console.log('timeout3'));
setTimeout(() =&gt; console.log('timeout4'));
</code></pre>
<p>在浏览器中，会输出如下结果:</p>
<pre><code>timeout1
timeout2
promise resolve
timeout3
timeout4
</code></pre>
<p>然而在低于v11.0.0版本的 Node.js 中，会输出以下结果:</p>
<pre><code>timeout1
timeout2
timeout3
timeout4
promise resolve
</code></pre>
<p>在 Node.js 的实现中，当程序横跨 C ++  /  JavaScript 边界时，会在事件循环( event loop )的每个阶段之间执行 process.nextTick 回调和微任务 (  microtasks, 例如，promise回调 )。因此，在执行 Promise 的回调之前，所有定时器的回调都会在事件循环( event loop )的定时器阶段执行，从而产生上述输出。</p>
<p>然而，浏览器和Node之间的这种矛盾的输出已经被讨论了很长一段时间了，并且一个特性（或bug修复）已经登陆 Node.js v11.0.0 用以跟踪浏览器行为。使用此功能，Node.js v11.0.0或更高版本将输出与浏览器输出匹配的以下内容：</p>
<pre><code>timeout1
timeout2
promise resolve
timeout3
timeout4
</code></pre>
<p>请参阅以下 Node v10.15.1 和 Node v11.10.0 之间的比较：</p>
<p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ca22d429-50db-40fd-a389-edf611079489/untitled?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45IHKPGFWL%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120545Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEAAaCXVzLXdlc3QtMiJIMEYCIQD7cIh6Ogu3uSmm1LmURDDLOhnyVAok8Yf9cpXGHZoVQgIhALx22mjTlUoVvLPE9xg1gxlR7BpaCyYWaraURiPylDAKKuMDCOn%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMMjc0NTY3MTQ5MzcwIgw2iGxPzJTAHFEAkHoqtwNX1BlUpi6okLhxieOgHtnAkg5hHKP3NwUssG9WM7PvyF1zS3%2F9qXiwRWwCpw9%2Bn3bsiIAzwpHZXGjsnGaQ2gwDzF83bk8gA6TDJ0nMY9FOftyxzW7E5nSxyFZYALR1hEEnJOHxsngssr%2B9ahKsSGKzGRVglYVlLQg1GIGIaWUNKZMjyCltOZeAIxV%2F%2FunsgiZmrxs1YqFVJq1fzt1XxMZbxqVo72yA1sC6%2Br2al%2FO7BnMHdHwlYSb4WQ4OsWeQ7fzNG1tnVl0540Idp2hzBhMv5Q84A8i0oNOKMYorj7Ysfv7k2Sg6Cw7bSPTBo%2Fmhfd7Vb%2FMfO%2BY6%2Bv%2FkH5s5GN2YrmpNBEh9%2BhHpEUXpQV1dpbhB%2FALWKPv9sV0%2BllFPZu8VKCTovbrwmNXFaHz5UwOtqSgSwEtFIOAhL0CHJNkaAEQ2xZoWVQklvfB3ni3JcBl8VDnsfanulYgmCUDrK%2FgainU4UY9VveReiu%2BBeNMPe3OobJGCCtCy9gy%2BjURt3A4MKNusa7xA3MotuSflIPY827yual90Ud7Cqo6u3O%2FlcuVNh6XnQCXNtf2PTRBq3HMpz%2F310culMKaPhu0FOrMBUzZpowHsAMtb9HgyA4UhHmsH9W%2BSjl%2BkIHHh%2Bp9cmGNXWXvlWz%2FOVIfkPAOvbhCs8lHUZhqvsFG9O4xN%2Bg23MVtrh12dJSjLswXbD39I%2F5Hlt9g6aZH8vmjAB2hP5F0bJaZTz%2F13sxIQrYLQS9u8mQepB3HRHb3VO9mohLDqzNKrncOAkCb7MJJRBzoYs1qgtRHBAnEk%2Fx32iwv12%2FC%2FBb%2BWrS7sSRz%2BeD14gpGODEjAKEI%3D&amp;X-Amz-Signature=41a70cb147d978f47017168b826ca73eccdfd8ef5153e4ab770d277d0c249b99&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22untitled%22" alt=""><br>
Different outputs in Node v10 and v11</p>
<p>此更改不仅会影响到 setTimeout，还会影响 setImmediate。让我们尝试在 Node v10 和Node v11 中运行以下代码，看看输出是怎样的:</p>
<pre><code>setImmediate(() =&gt; console.log('immediate1'));
setImmediate(() =&gt; {
    console.log('immediate2')
    Promise.resolve().then(() =&gt; console.log('promise resolve'))
});
setImmediate(() =&gt; console.log('immediate3'));
setImmediate(() =&gt; console.log('immediate4'));
</code></pre>
<p>Node.js v10 和 Node.js v11 明确地给出了两个不同的输出：</p>
<figure data-type="image" tabindex="1"><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/14a4d2e1-5e40-44ce-a5bc-52dd5ffbc8ab/untitled?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45ONFOS75K%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120533Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIFXVh8HY55tza4cXP7A8AAAasLjdsPmkOAzSmAHeqJn1AiBf14AV8z6WeXTfPCQJLxJpFo%2BbQPHM0jDTRECHkWDLEyrjAwjo%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDI3NDU2NzE0OTM3MCIMW0PS2PjOwTS1YDQTKrcDyerVOXeZZ8oqjMXH3z%2FAIWjy6Ebv2mBzdPxqAv0DNrNbhJ9GBBndQ8NHn3oO9U9UgJzId4CTKoWagYRY%2FVCBLFH56%2BtOb4RVB80fJG%2FwrM0S6riX%2BZPIE0LzzPGBbi%2BUhjMOqwTycgw8gNlIYYJOiVaKIOytLKqk18YThdwr48arh9rKyZ4vJYAWz7fXRSZptkDPtsRnqWDH2Ns7Jlen%2Bn9ske3bkrY8WOl7usxRO8PCwrcWW%2By2qf8zFekZBMRNCSUNdtMqpBDq4pXP73X0hQbhNg%2BZIAAGXipTPIUZAUYIzK%2FKtIlu0HQ3HnFLE9ebJsHPXbTuV89NTcUi4KHGnY1AzfVmHAfHP%2FS4NtCZkCu9ewO6rGw3OJAP9esozyr9mu6nnHDpGw9r7UMW30I3sMkkgCFZl1oM92o36h4IPJVGDAoAZ8Z6lV%2Fu8T17zpvFGNR2x6Okc5RIZqmz2Grk8Bcpo4cmxj%2FsT9%2Br1DANzBtvZR8dJqjTs2woCbxf5dlPutYMaVCB1WWFD7X4%2Bn9idHq033d9dzUPt4S7p4uX3%2F9uihQATZBdgFOo65MFp%2F3cXMO0G07GHzD69oXtBTq1AeY5bcKG%2Bz3Mg54SBAvFiQ1n%2F3pu220PXsTIaqXvFBKSXUm%2BYBvkYzSGygE0gZu92ZVFhLCVJalSzp%2BwcucqDbLbfrMkeCn%2FQIDHVTpoI6CR%2Fi0ZIqe4e8BgKZ5tOFKV%2B%2F71i6aJ18F0%2FzLR0pXbc0GaeW6E6kJnGxrZwbfWviooJJNXacln6iuvIS%2BUrtoj%2BMsb98E2tSM9UqWpqLcr5sMmc4kkxmyxRLZ3zM51TpHklHFHOho%3D&amp;X-Amz-Signature=ddab24370e2a688e968a080477ad79f98be8f97abd0a23451c6515f4dc54a41a&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22untitled%22" alt=""></figure>
<p>如果您替换 Promise.resolve（）然后使用 process.nextTick，则此结果完全相同，因为微任务是在运行 process.nextTick 回调之后才会运行。让我们尝试运行以下代码段：</p>
<pre><code>setImmediate(() =&gt; console.log('timeout1'));
setImmediate(() =&gt; {
    console.log('timeout2')
    process.nextTick(() =&gt; console.log('next tick'))
});
setImmediate(() =&gt; console.log('timeout3'));
setImmediate(() =&gt; console.log('timeout4'));
</code></pre>
<p>上述脚本在 Node.js v10 和 Node.js  v11 中的输出如下：</p>
<figure data-type="image" tabindex="2"><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b84ac947-af7a-446b-a959-23db4f52ab10/untitled?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45CXUAYZWA%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120446Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCJ7oIbNAtX2v369L2krOhV%2BqbpEY1X9ch3xdsIexPKZwIhAOFAyPEvPdUcrIj61GZOQuNHz6NY5HjrAaXFBq4aED9HKuMDCOj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMMjc0NTY3MTQ5MzcwIgxf5QY9SHTwFz9aY5kqtwPgaV%2Fiw2STipPnG7MzSsSVBeimQQ4o2L%2FUC0pVw9mohITvRqsYbMhMGm%2FQ9qKqyYvmKUDolG4A8xxEZOynbBoSKiicwU6DYpEHqjqCTpkjqSCBSxaG9uyLXJo2YQzbn3oQ0F3aLgYKh8Xmj6c75Rzkk3fAufTkBQcs%2Fe0LJOr9ptInNHMzstRHYlNTUOnF2Spj%2FCXl8%2B0PLUuVhfPrYTi424azWQNL2enqzbb1fpRb9dAxr6z%2FRDjLlmVfNz4vo9ag767%2FRARYSRnhAmKAT6toJafrJsa%2B6F7DoTWf7EIqrk4DrBYinM9XRz96WCX%2FS89QtxQc2yhXua%2BIUZbrajS0ag%2FzJzBRwzmXriSPtp5pvEw9cJwtrdKhiTtnmOqD1iAaTaXDHs6AfP693zHo%2BPrHdZhWAPhKjZnhncUYFpzPsxJPNE69x14J0zBQcJsgALPUhHOKPv4ArOPzzKlwlABkqS%2FPRmGHTWuDxi4Z6NSmsqGfK1ZdmUnFZ7oMmYcZaXgHwNrm6JzO%2FgNFohj27wpTou8G95CzmJqO7n7QiDij7vCMHqHTRR%2BRkuqZ%2Bv2gm1dAiywtXMHNMPLvhe0FOrMB%2BphHhVxJ5lnhblEY1ZVuS17FV1Bomyr5JrPJzESKN%2BEyHmo8VoGSqTNbIvt1h5kcuhC%2FVdxqGYERwOY%2FFrTucQWGvj5cdhgBXuPJokqlRyPTRsiPpQ4oOWuv93HeV1BKFQD05GshSeCVXO87Rjd4gqtmD1ddP2dAJStAio3KxIbB8gnv2DCXgspkncSywBjP78eV2mykGyxvkO5jfp4NilDMLZFd%2FgxRRqn1ecgQC3gFEe4%3D&amp;X-Amz-Signature=7e792e689db5fa9456902102730ca49895426a6a48fd836a492964aace21a178&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22untitled%22" alt=""></figure>
<h2 id="这其中发生了什么">这其中发生了什么？</h2>
<p>随着 Node v11 的新改动，nextTick 回调 和 微任务( microtasks )将在每个单独的 setTimeout 和setImmediate 回调之间运行，即使定时器队列或 immediates 队列不为空。就setTimeout 和 Promise 回调而言，Node.js v11中的新改动与浏览器行为相匹配，从而提高了 Node.js 中浏览器JavaScript的可重用性。但是，这一重大变化可能会破坏明确依赖旧行为的现有的 Node.js 应用程序。因此，如果要升级到Node v11或更高版本（最好是下一个LTS v12），您可能需要谨慎考虑。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[译] 跟着例子学 monorepo (一)]]></title>
        <id>https://x956606865.github.io/conceal-name//post/yi-gen-zhao-li-zi-xue-monorepo-yi</id>
        <link href="https://x956606865.github.io/conceal-name//post/yi-gen-zhao-li-zi-xue-monorepo-yi">
        </link>
        <updated>2019-01-25T11:57:10.000Z</updated>
        <summary type="html"><![CDATA[<p>原文链接:  <a href="https://codeburst.io/monorepos-by-example-part-1-3a883b49047e">https://codeburst.io/monorepos-by-example-part-1-3a883b49047e</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>原文链接:  <a href="https://codeburst.io/monorepos-by-example-part-1-3a883b49047e">https://codeburst.io/monorepos-by-example-part-1-3a883b49047e</a></p>
<!-- more -->
<p>让我们通过实例来探索 monorepos.</p>
<figure data-type="image" tabindex="1"><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6c320ff3-c7a8-4673-864d-86dd61a42b31/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45MSRJ7VNW%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120642Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEAAaCXVzLXdlc3QtMiJHMEUCIQDxMSzMZ6jd9XKBzRKqzL5nrcGb9z7v38n9To2RRhRBdwIgLXinDAM9oUp6QrCLo2RpNQ2xeam6bLTMgGc%2FM8rZ5UQq4wMI6f%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDOJkK8XwXItE8Th7iCq3A7V9680a4NGC%2BM6IrB8JQqCNhQO6SM39nNEv8THQ9Uj0NLuIP2f%2BtWeWc00wmD0Ede3Tlv8vcEKCSDHY9uwUBxzV3PqVGEX%2FaV0VMML3pLDZRxqkjGyp7ELJ%2BMg5iaV7dFxk7uURWPyn7CdVfmsgY2XLC5mfaRnXQHCikrvHFA0A7PMFoPoJXp8K5Nkt43sKQCwSOJINWii5orJoXkno4tPGlIkoy1woEBZd%2FHE9YM0h5Soez9qYje0e2pMOFdNFmC%2BEY%2BUauYQnXo22hilKsqFEqfUxe1%2BLNjGUgQjh4gM0aAi0ud9vRuAMUMazq4il23uBdIqes9Mtge%2B6Kvqw9nocgqGGg57edHdM4IFwoDaM6M52KSfRMQpHa4c6l%2FG7tG0XeShMU3ojhty51iysmvypxuBVgKT7ozUg8pq8GZMVOBo8c4UnwZ5ip%2BaEbcRiiJFH1267kFtOdEvOTf6813AiZofv1RXxDMYVfWcEnWe9yLamrQoy9uUdq664Re5PRppybvymkAiWht6awoO0uBRGuETvxnqydcApq3nI3FF2yIIeuAvki1rXR5Y3BhuSRcbyhRYVk9Aw0I6G7QU6tAF3ViJTpyXgJsd61h1AHwg2cRIXNBDR%2FNCHmXUHl2hLOzCh20%2B5m3b9L%2BQ034RtSGuYoiWOqz5ZKP2fI5b1CaqkVX%2BWf6uYRn2aEfLHK%2FPA9uqOo6MpXNBPJXjY2dEBTx%2Fr7rU%2FEMZkLQyw9IYD%2BRyRm1nw0dt72Smv86PrwqDap%2FjaQy7HAE6GpazithtM5AMEnNl3ykK6PXz7gsY1VmC4z9dITceA9IjjjukWbtmfbUXiI0M%3D&amp;X-Amz-Signature=890a8bc1afe6a8c11ced249a506fbadb40c858c167b1633a8db20a6cc71b9c1a&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></figure>
<p>首先，关于 monorepo:</p>
<blockquote>
<p>Definitions vary, but we define a monorepo as follows:<br>
The repository contains more than one logical project (e.g. an iOS client and a web-application)<br>
These projects are most likely unrelated, loosely connected or can be connected by other means (e.g via dependency management tools)<br>
The repository is large in many ways:</p>
</blockquote>
<ul>
<li>Number of commits</li>
<li>Number of branches and/or tags</li>
<li>Number of files tracked</li>
<li>Size of content tracked (as measured by looking at the .git directory of the repository)</li>
</ul>
<p>Atlassian — Monorepos in Git.</p>
<p>其次，我也赞同这些反对 monorepo 项目的论据:</p>
<p><a href="https://medium.com/@maoberlehner/monorepos-in-the-wild-33c6eb246cb9">Monorepos in the Wild - Markus Oberlehner - Medium</a></p>
<p>接下来，我们将通过示例来讨论几个实际的问题，使用 lerna 来管理一个 monorepo 项目（ javascript 项目 ) .</p>
<p>这个系列的最终 monorepo 在这里，<a href="https://github.com/larkintuckerllc/hello-monorepo">点击查看</a>.</p>
<h2 id="脚手架">脚手架</h2>
<p>在我们处理 monprepo项目 ( 特别是lerna所管理的monorepo项目 ) 的问题时,  我们需要先建立一个 lerna monorepo 项目,  幸运的是这十分的简单.</p>
<p>首先,  全局安装lerna:</p>
<pre><code>sudo npm install --global lerna
</code></pre>
<p><strong>注意</strong>:  本教程使用的是nodejs v8.9.4 与 Lerna  v2.9.0</p>
<p>创建一个新的文件夹,  并在其中运行一下命令将其转换为一个Lerna monorepo 项目.</p>
<pre><code>git init
lerna init
</code></pre>
<p>最后生成的文件夹结构应该是这个样子的:</p>
<figure data-type="image" tabindex="2"><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e6236042-0794-4d12-a3bb-5f7f6673c9d8/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45ONFOS75K%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120703Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIFXVh8HY55tza4cXP7A8AAAasLjdsPmkOAzSmAHeqJn1AiBf14AV8z6WeXTfPCQJLxJpFo%2BbQPHM0jDTRECHkWDLEyrjAwjo%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDI3NDU2NzE0OTM3MCIMW0PS2PjOwTS1YDQTKrcDyerVOXeZZ8oqjMXH3z%2FAIWjy6Ebv2mBzdPxqAv0DNrNbhJ9GBBndQ8NHn3oO9U9UgJzId4CTKoWagYRY%2FVCBLFH56%2BtOb4RVB80fJG%2FwrM0S6riX%2BZPIE0LzzPGBbi%2BUhjMOqwTycgw8gNlIYYJOiVaKIOytLKqk18YThdwr48arh9rKyZ4vJYAWz7fXRSZptkDPtsRnqWDH2Ns7Jlen%2Bn9ske3bkrY8WOl7usxRO8PCwrcWW%2By2qf8zFekZBMRNCSUNdtMqpBDq4pXP73X0hQbhNg%2BZIAAGXipTPIUZAUYIzK%2FKtIlu0HQ3HnFLE9ebJsHPXbTuV89NTcUi4KHGnY1AzfVmHAfHP%2FS4NtCZkCu9ewO6rGw3OJAP9esozyr9mu6nnHDpGw9r7UMW30I3sMkkgCFZl1oM92o36h4IPJVGDAoAZ8Z6lV%2Fu8T17zpvFGNR2x6Okc5RIZqmz2Grk8Bcpo4cmxj%2FsT9%2Br1DANzBtvZR8dJqjTs2woCbxf5dlPutYMaVCB1WWFD7X4%2Bn9idHq033d9dzUPt4S7p4uX3%2F9uihQATZBdgFOo65MFp%2F3cXMO0G07GHzD69oXtBTq1AeY5bcKG%2Bz3Mg54SBAvFiQ1n%2F3pu220PXsTIaqXvFBKSXUm%2BYBvkYzSGygE0gZu92ZVFhLCVJalSzp%2BwcucqDbLbfrMkeCn%2FQIDHVTpoI6CR%2Fi0ZIqe4e8BgKZ5tOFKV%2B%2F71i6aJ18F0%2FzLR0pXbc0GaeW6E6kJnGxrZwbfWviooJJNXacln6iuvIS%2BUrtoj%2BMsb98E2tSM9UqWpqLcr5sMmc4kkxmyxRLZ3zM51TpHklHFHOho%3D&amp;X-Amz-Signature=c8a2712d091e11648e627377de26b28e83dc74c6fc855a167660dd11d73ba6f8&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></figure>
<h2 id="创建第一个package">创建第一个package</h2>
<p>现在，我们已经有了一个 Lerna monorepo 项目,  就可以开始尝试创建 package 了.  在部署到 npm 仓库中时,  每个package 将会是以单独的一个 npm package 的形式存在的.  通俗来说就是,  package 允许更松散的耦合以及独立的依赖管理( 稍后会做介绍 ).</p>
<p>我们可以通过在 packages 文件夹下新建一个文件的形式来创建一个 package, 并在对应目录下执行以下命令 :</p>
<pre><code>npm init -y
</code></pre>
<p>这时，项目文件夹结构会类似这样:</p>
<figure data-type="image" tabindex="3"><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/36ddea1a-a400-4be3-b787-81bce47bc391/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45LZLCVEHV%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120718Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEAAaCXVzLXdlc3QtMiJHMEUCIHeMXwTjQdYh2X0En3fLEOTR6btDLr7YHVQ2FWzlgiIVAiEAjU4JQA9aCxXoc28K%2Bc2028wbRvjcaCGLPgl6UpztDMIq4wMI6f%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDMTLLo2flcj%2BLKam2Sq3AyPNa8l7%2FyI%2B44Lkx6IdK4Mn5o1Ahu9nfBAD5HpChinlIipZ6WyJ4ILx4OCFQ69%2BRnoY3HBXK2EAQ4N9rEsPAmat%2Fktb4TfhK3Ake1xB9VgB%2FPMbBpMbT%2FrsQe6B%2BOosNxfe41g4FXE5SJ%2BzagOgMUJr%2BK4qlfsCfactdANoS%2BUgoaQtR7l7d%2BcuP1Qr8T6q63ARni8KCj9YjEm4HQQpmEsjlBvc4d2DMxUK8C6rM58Uhygb%2FMUWrw7fx4nQ3qv%2FEQekHdik76GJiFGn9TK%2Bv7Olg1t8zYxhL10Tz707ktx5DpMvcA5LI8YdzFeabEjeVfifmUHfH374SvK5pDQ39eCtqZnH%2FCYgOT3HcFFzuEGCSb3Vhvks5PYbr2PsxDudgNs0uxB4ekjT0LYL668qiZRSE%2FGpYNXBSreLA3dvkmzi8NJ4TZTL2St9N14UYClLQA4AgfCZIXascKB0s%2BJIEITizxdwi5TRnjNooESqAHeYnbgoPvmefurEFwhxehDbKeQNAe7ykv3sGz94HftY61WYkjCsJ7bgPEWn6tLHALByrPt2%2Fm8M7wu5N%2FdcMOrKQs7m7elYb3gws4%2BG7QU6tAFQhZKUIAJusg7%2F3ZS3opmS3zZ2tpkU%2BjRC6NaOFlzSvh%2BMKgNbYuwlAQTo9A%2BdCTCpNl%2BLNdVuokbfZhCb90KxJzoOxSvZYLkRD61oITou5SbCH7eV8I%2FIBGT77GJa7ZjRhbnV1aGsRKPJLj0aRv5CxAR1nPKJKG%2BfALixgyFaoQcs5XNZj89fkmGeyUdAiUXbURcZULcGYmM0rmiQFjCKqxCxJSF7XQvBEcclgBplp1NcIsI%3D&amp;X-Amz-Signature=7597a8b79d9d38dc9f5d79568bfe6cd39cf85a48c35b9ea98f870dafc73b9cf5&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></figure>
<h2 id="第三方依赖">第三方依赖</h2>
<p>假设我们三个项目都依赖于 npm 包 sillyname@0.0.3  ( 特定版本 ),  我们可以运行命令: ( Lerna 命令可以在项目下的任何文件夹中执行  )</p>
<pre><code>lerna add sillyname@0.0.3
</code></pre>
<p>然后, 项目的目录结构将会是类似于这样的:</p>
<figure data-type="image" tabindex="4"><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a3da5a86-d2b0-4d67-ae24-5a29e3aef528/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45A7KMKUXE%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120730Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQD1YLxe6Z4xK7f9s92jKIoPV1WGXuoif8s0%2B8ztdLoEJQIgfdRgDpR3mW2xjvEqaMYTGHpLZjzTBwYaQEA7uLwWHJIq4wMI6P%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDEtlJzYXgtUWFHsbLiq3A1Nn9CPRRM6WTVXxhihGPbjfO3H9%2F8G7qsnow1l7omXs5m3Udae%2Fy64qBsukWxD5S5Ejmh4HxQGUnE70PlMrJ%2FSeEBV6DA%2B5UZoum5ltgju%2FAqLeHNpnMNhWfXg99Z%2FUFGC2iQ1uDYWW7Zu6iHR7gUbaUwgnwdFzN0AdiP3ivTqLbBbfhmSYdXERm2uXXEN00J5rJoBKfcs2YcdaxW9sbOK2ofUSkeywGPorvNZafPV0zfxan5HtoHIsHzbSdsaLXF4AHyluLQax%2FJeEXgNtYDjT7nB6qXI8dvM%2FJDOM9TWzfDsYB35oBow%2Bo0gmSuiu6swdr8KtiSESGMV9G6zoZwD6O4OGMrByxpdL4bCBRc2JquUVIrvV7tPCu09rTfEYRlKUsVJjnJWV%2FP5Wjcxu8qpscEDwCIDXTexx1s%2BQZuAeZkO3CnUwuIZZdQszsveb2mx3fw9krcka5RP%2FPdst4yceXbSh8H6lw9hN23f%2BLwX0IhR8hmZAwfkMlNwXnldot6WUNH1CDR%2FhTOUNFOXQmSKc0hvcYUP4mCiyoW9Y%2FLYydfc3U62KuYXq8YSl5SYm9n5JmlQhfs4wmvuF7QU6tAFL3sCn6xEh7aHadhzQywv0LOZMOkjUUntvrbohmii3t3XsB%2Bjw%2Feo6q%2F2u%2FosNoxCBRVpBaeM12eoPovzwcdZam1DLYqYogJXCHaVPavk0Fe6pMCt4MTNoUGD5Mvvw5utZSs%2F2z%2FhK8t8YuhE4uxETvks061IHArE1ovtvz6qDc87q%2Be%2BJo8R14t7C0jWtPMVnGu7C4Onls5HQG4l1F4nBGLIuwD22jQbylDa1FNH56NVKJB8%3D&amp;X-Amz-Signature=e71c2a1903a71ff06fb13440b3c08446e09ca49285f3a7b7b652caf78802d078&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></figure>
<p>显然:</p>
<ul>
<li>因为我们希望每个 package 都是独立的，所以每个 package 都会更新自己的 package.json 具有对 sillyname 的依赖.</li>
<li>注意，他生成了 package-lock.json ( 很像 yarn , npm 现在锁定了二级依赖 ). 另外,  Lerna 文档中提到, 他也是支持 yarn 的.</li>
<li>使用 Lerna 我们可以使用一条命令将依赖安装到每个 package 中.</li>
<li>每个 package 都有着自己的 sillyname 副本, 安装缓慢同时也浪费磁盘.</li>
<li>一种更高效的方式便是手动更新每个包的 package.json 然后在父文件夹的 node_modules 中安装 sillyname ( nodejs 是会在父文件夹中查找依赖的 ), 不过这是令人乏味的.</li>
</ul>
<p>对此, Lerna 也有着解决方法; 使用  <em>hoist</em> 参数</p>
<pre><code>lerna add sillyname@0.0.3 --hoist
</code></pre>
<p>最后的项目文件夹结构将会是这样的 (截图中并没有展示庞大的 node_modules 文件夹) :</p>
<figure data-type="image" tabindex="5"><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/519f0c3d-d351-4a2a-b9e1-8b780837ba33/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45DEWQT7VH%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120747Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEAAaCXVzLXdlc3QtMiJIMEYCIQCTNeZsUW4kWuDjxCem3bAMns7l0qqj5r7%2BUhHu6eDWCwIhAKgCov7rmj7qt7F6uUgn%2BJ3CjFU2eVxz6zMs2lSywgNTKuMDCOn%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMMjc0NTY3MTQ5MzcwIgxtrFZF0%2FlxfKQKP6kqtwPUFlgOSZr3faYZAgwoRUCglBwFnfj7COe9mzidJ58Q96UJO5R73YYHkcWOqwPmrZDqcy6rScKV5GBg8a8meQaWBpUIqTW4ry%2FZsEccYxMnVS1w%2FbQsLO8roqwjcvJr13zT0msp%2Bqy%2FU0PhaYTMF4yJtcuvHz35VS0tcTVTmXsgdbH43eB7lEbrehsY3c6RysOpNNfNz0YDRcXhEwEIOZodS4oy2BYjj4bA9CZEXbhbuNOla37PzFPhGS1H4M9X0SLpqDXTln0vLThqO9jzTto2fBAJsHRidCt3hOznqDvhkh3VThvmg%2BEq4Y85gSIO8UVJ2XBUzoBnuH8qEdVqNlxYLGScfleTckTU%2BtDt0DVd%2FVomcAZOdOIiGc3iaG2KU129sJsVOu7b3FhqGToNXnTKiT0870PJjnYnhVtZvm5ptC%2FwCUGAqxAzjNVgPEGxHDdASnWP3T1Zvw%2BWPGSPyAvDNQCIWylInaWmA7Osw6AjVrrix89PkMyKYSEMH1yK8%2FI%2FT5QqECNgHqi8ZmhfiXYxjknlY1Whq0qQnsKYGDZqp9PBYICyAgEXDS3IUvLBpNuEUGW%2BzMkNMI%2F%2Fhe0FOrMBAUbPzXUS61xlonQk2PQQwSzZgCMPOY9nPZO15TLmU5mjLAMVYK%2FatSNa3atKN6VdybjsWiUDCWgC4tNcSCkcKhGE3fXQquQfEvX9RDSF%2BgvOCpjNuA3vr5lgalT6zconZzxBA9fpDiJ95Ekr2Wx6J2Qc0mcql2mW%2BQooyOFZwVIe3iiJPVew9dCHmr6Ay2uQ1emi10nB7%2FNcEivMigzcYmfrR0ApVVb2%2BFK2buyy1nrbxQQ%3D&amp;X-Amz-Signature=ee9ff4d07bbb8f58b17793ec8cbfdaca991cd5c6f3cac29d894f720754e034f6&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></figure>
<p>显然:</p>
<ul>
<li>每个 package.json 都将 sillyname 列为依赖项.</li>
<li>sillyname 安装在了项目根目录的 node_modules 文件夹中</li>
<li>node_modules 中的其他软件包是因为 Lerna 是软件的开发依赖.</li>
</ul>
<h2 id="有选择的升级">有选择的升级</h2>
<p>假如我们只想为 grocery 这个 package 升级 sillyname 的版本, 我们可以执行以下命令:</p>
<pre><code>lerna add sillyname@0.1.0 --scope=grocery
</code></pre>
<p>然后, 项目的目录结构将会是类似于这样的:</p>
<figure data-type="image" tabindex="6"><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/59129a27-7714-4d98-973f-a5ee45c08ffc/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45OC3NB4GW%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120800Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEAAaCXVzLXdlc3QtMiJHMEUCIQDhTqc1Jnwj6mIVYJjwbKRo2eQPmLA3npna%2B%2FA00mj6WgIgTt%2BiHMXaChYKcdsWuH3968hh4ifm7ezsvAv72bv8Dgkq4wMI6f%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDKetLgzXi4ziNzxeDCq3A1Ocd1eRgkabUgdynq0EUQHutC47P3ygEWOiyXXn2Ezf2NG8zVxzloEXX9Yo%2BzoOqrglkXIJ57B49UCmjpQDV69z%2FT6ktjH0%2F9yJyP%2BYnhKRsL8UgrXU5RAvzSN18o2x2vw8chr6UIF3FZC%2Fa7w7d519joBZtyUsZEciBM26TWEyabU60jSPb3JZCBtkWElKWZIfWWxOllSJpNCd1kHJWX8QlxCtP%2Bnp%2BDAMU4HHas0L7L%2BHRsCXcpnZz5Lun2fYTzfE5QxupQCrg%2B5JGYJgPj7pAs%2BYX2cKWQpik6OF9rpmYLXEMJwJApXgwdhPLxbJQSoeqCcyclRUzR1Aj%2B2iCZH4MsTZrEeILhgBZpCzSoZKKjm71FWl4ASNdHhEOWngzP4QppQYvv0sl8kTs1ZEOlWlWBU9TfSndlb9cH2mDJpY5O5xokgOToQfEqftttMZXlLPEJUuJIEG2FvGruQjnYxdrRzxfYknjs0q3Hj2xm88lZmUV69DW%2BXVtCDgG3bPDiRHe6O%2FxSX5t77QvURc6do11iJRfEvf3%2BzDFp1Sn1DR8RwuYLoUJToWz12prKmmc7NPcUQ76igwgoaG7QU6tAFVgts3DCcXsNqqPFNRgsGCDc8h8tS6edOi3OcMtvLIT2cDlcKcmOr4Sv%2Fgk5688L%2BgH1Wmy6F65fHBC%2Fw2Y59jZJPgwkndSpYbrDoJvYISQ%2BherYC2LPnIcxCbyJRQyiyWWlgDWov3gzBWZSUOIowO7RvkCIy29OtdOiDY7dw7%2FfgBO6DZaW3PJt1rO5CpfiZfWoDBBSJGGvIV2sl3ROZx1Pj25m5h%2FFZgRqSaqcqF7IuInDY%3D&amp;X-Amz-Signature=f0169fe7bc8c3da4a505d7e5d3e7b975ef98448674f29a405b107c9c73ce2bc3&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></figure>
<p>显然:</p>
<ul>
<li>grocery 的 package.json 会更新为依赖 sillyname@0.1.0</li>
<li>grocery 文件夹下会有一个 node_modules, 其中包含了新版本的 sillyname</li>
</ul>
<h2 id="内部依赖">内部依赖</h2>
<p>现在, 加入我们希望 grocery 去依赖 apple 和 banana, 我们可以执行以下命令:</p>
<pre><code>lerna add apple banana --scope=grocery
</code></pre>
<p>最后的项目文件夹结构将会是这样的</p>
<figure data-type="image" tabindex="7"><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/894d88e0-af5e-4888-9fbe-724ddaa9030b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45AVFIE2OT%2F20191012%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20191012T120817Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCBTc4PJH8QtP3ilSv4Oz7EMiZbYza8Cau9tl1j7L5%2B8wIhAMcvg%2FXheFlPTe3xX19OiDvpG0XB1XydWbzkVGdnCh8AKuMDCOj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMMjc0NTY3MTQ5MzcwIgzzMDBbl3pdBO16vdcqtwOtY%2BYs1XzZaUN7HdryTaDunWze4jKG52Z%2BYwOd1BdFUN8ba9Sz2tY7xu532G%2BtsmNX0IzFCr0N2Mf9y52uto8Pb%2B7YhcDeyzv1Tj2%2FbGBfBSvdSciitxDAga3WnDXGQAwXAFUomSMB50BGl%2B3KNVsG2m7ftGBLiudsbZ5Xm4Cm64Y4%2BRZi6bnt8xqVoX3%2BKQamc0s3jyC6XevxaBYm2j2YjcUIQQXmG9nXnkoACRTVPo4BqWjlLY%2FWlLARGjFbX5R9VlcD6oSJqpxJn%2BrueT05rxzRfp0gNAEr3gUVXk6puUkEiYx6iehqZCpaDgw2KVgurhXQzs4H%2BJVvYM1qO1qI7nSNhQ02JXqmOhvWlrzf%2BIYHfy3f7uJiNhujN664F63SiLOMsIXlBERL7T%2Bwv8TzIGK0phlUzuq%2BLiYacGzM0fxmIbWUlzErmEbar8HhWWbCZAdqMAP4v8oJf903%2B4o5TLKZ0Vo1d1xEE%2FCyMJ%2FtRxsFCaC3NMtRIab4RoaqQ0Ta6YbJDH6AS5uoHuztZEnpA3C109WKfmw4kk3g5KB7KBfn0N1M7WuN3YFKkbY3N3IGgxYnM3KDMJv8he0FOrMB2Mdch5WiRjnYOi6rxEwW2LmxmKaKViEiOIRNXzIBEzmKGHr8%2BLk17C8v6vqvS%2FpqaAjqruRTQcdGmYUm3sIxJc2MYvqb0ie1eItv4PmPKaIm8Ed9Zblu1hb%2FbsW9qer0jT2FomdlV5jCYxZt1GKG5ZDrWzZkbnV7RGX3dV7XnBg6tc0IG%2Fq%2BdFZJVz1MwGcRaRDhWFzBQm%2F3cyBXUgMFPkFlH2OoKBckXijR8TXODKCqVmA%3D&amp;X-Amz-Signature=143de3cfaaa805715d562c0d9cfcd5823970d76dee0ec45700d057fc04d37d92&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></figure>
<p>显然:</p>
<ul>
<li>grocery 的 package.json 已更新, 依赖于 apple 和 banana.</li>
<li>Lerna 在 grocery 的 node_modules 文件夹中创建了软连接, 运行 grocery 透明的访问 apple 和 banana 中的文件.</li>
</ul>
<h2 id="相关代码">相关代码</h2>
<p>现在, 我们已经设置好了相关依赖, 可以开始编写一些代码了.</p>
<p><em>packages/apple/index.js</em></p>
<pre><code>const sillyname = require('sillyname');
module.exports = `apple and ${sillyname()}`;
</code></pre>
<p><em>packages/banana/index.js</em></p>
<pre><code>const sillyname = require('sillyname');
module.exports = `banana and ${sillyname()}`;
</code></pre>
<p><em>packages/apple/grocery.js</em></p>
<pre><code>const sillyname = require('sillyname');
const apple = require('apple');
const banana = require('banana');
console.log(`grocery and ${sillyname()}`);
console.log(apple);
console.log(banana);
</code></pre>
<p>然后在 grocery 的目录下运行一下命令:</p>
<pre><code>node index.js
</code></pre>
<p>最后的输出会是这样的:</p>
<pre><code>grocery and Linenhiss Butterfly
apple and Trailspeaker Scribe
banana and Translucentpuma Kangaroo
</code></pre>
<p>完成编码后, 我们添加以下文件, 因为我们不希望将 node_modules 文件夹存储在源代码管理中.</p>
<p><em>.gitignore</em></p>
<pre><code>**/node_modules
</code></pre>
<p>然后将所有的文件提交到 git 仓库之中.</p>
<h2 id="bootstrap">Bootstrap</h2>
<p>现在, 假如团队的另一名成员要加入开发. 首先, 他需要全局安装 Lerna.</p>
<pre><code>sudo npm install --global lerna
</code></pre>
<p>然后, 他需要克隆仓库, 然后运行对应的名来安装所有依赖 ( 包括符号链接 ):</p>
<pre><code>lerna bootstrap --hoist
</code></pre>
<p>现在, 这么成员就可以开始编码了. 遵循他们自己的工作流模式 (创建新分支等等).</p>
<h2 id="下一步">下一步</h2>
<p>在下一篇文章<a href="https://medium.com/@johntucker_48673/monorepos-by-example-part-2-4153712cfa31">Monorepos By Example：Part 2</a> ( 未翻译 )中，我们将继续探讨一些更实际的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lerna学习（三）发布篇]]></title>
        <id>https://x956606865.github.io/conceal-name//post/lerna-xue-xi-san-fa-bu-pian</id>
        <link href="https://x956606865.github.io/conceal-name//post/lerna-xue-xi-san-fa-bu-pian">
        </link>
        <updated>2018-11-24T11:54:37.000Z</updated>
        <summary type="html"><![CDATA[<p>接着之前的思路，现在我们已经完成了项目的初始化构建，然后开始往里面写新的package。</p>
<p>在写入的package后就需要涉及到上传的问题了，如果是开源项目，那直接使用lerna的publish命令即可。但是比如一些公司的技术沉淀之类的整合，有很多是不适合直接公开在网络上的，所以需要的是上传私有库。比起npm的私有包的方案，其实我更倾向于搭建私有npm仓库的做法。一来，代码是存储在自己的服务器的。二来，lerna也默认不允许直接发布私有包。</p>
]]></summary>
        <content type="html"><![CDATA[<p>接着之前的思路，现在我们已经完成了项目的初始化构建，然后开始往里面写新的package。</p>
<p>在写入的package后就需要涉及到上传的问题了，如果是开源项目，那直接使用lerna的publish命令即可。但是比如一些公司的技术沉淀之类的整合，有很多是不适合直接公开在网络上的，所以需要的是上传私有库。比起npm的私有包的方案，其实我更倾向于搭建私有npm仓库的做法。一来，代码是存储在自己的服务器的。二来，lerna也默认不允许直接发布私有包。</p>
<!-- more -->
<h2 id="私有npm仓库的搭建">私有npm仓库的搭建</h2>
<p>目前网络上开源的构建私有npm的框架很多。最出名的就是淘宝cnpm开源的<a href="https://github.com/cnpm/cnpmjs.org">cnpm.org</a>，这个库可以说把整个cnpm的功能都实现的，功能十分强大。不过代价就是搭建十分麻烦，而且较为不稳定，时常出现奇怪的bug。</p>
<p>对于普通公司来说，其实并没有那么全的功能需求的，其实只要满足基本的功能就足够使用了。所以这里我选择的是一个十分小众的框架<a href="https://cevio.github.io/cpm/">CPM</a></p>
<p>这个框架的搭建十分简单，按照官方文档搭建，很快便可以搭建成功。不过有几个要注意的点:</p>
<ul>
<li>
<p>在导入数据库的时候，文档说的很模糊。其实根目录下有一个database.sql文件，如果你不是使用navcat之类的图像化工具，那么你就需要用mysql命令登入mysql，然后:</p>
<pre><code>  &gt; create database cpm;
  &gt; use cpm;
  &gt; source ./database.sql;
</code></pre>
<p>因为他提供的sql文件本身不会去创建数据库，所以你需要自己去创建，并切换。</p>
</li>
<li>
<p>不同于cnpm.org，cnpm.org使用了两个端口，一个用作仓库，一个用作web服务。对于cpm来说，他只会暴露一个端口。在不修改package.json的情况下，dev模式是7002，production是7001。所以会出现一些问题。比如文档建议在上线时，将config设置中的registryHost直接修改成你的域名，不带端口。并且示例中使用的也直接是域名。这样就会带来一个问题，你的服务跑在了7001端口，但是你的仓库被设置成了80端口。看起来能用。但是当你上传package后，就会发现没法下载，因为80端口去找下载包就会出现404错误。解决方法，要么保持registryHost是7001端口，要么去修改package.json为80端口，然后重新上传package。</p>
</li>
<li>
<p>对于数据库配置，如果你的数据库不是跑在默认的3306端口，在设置plugin的时候需要手动加上port这个字段。（还好字段名称没有被作者魔改）</p>
</li>
<li>
<p>因为私有包必须以自身的scope为前缀命名，比如@exampleScope/packageName，所以请务必记住 将自己公司用的scope名称添加到app/service/authorization.js允许的scope数组中，不然可能会无法上传。</p>
</li>
<li>
<p>对于package的命名，除了需要一scope作为前缀，同时还需要注意的是不可以使用驼峰法，请务必使用中划线分割单词。因为驼峰法会被分割成多级目录的格式。这样的话会触发cpm的一个bug，如果安装时一般的包找不到会包一个json格式的错误，说本地没有这个包。如果是这种被分割成了多级目录，由于没有触发到路由的匹配，所以会报一个404的文本回来，从来导致本地触发报错说json数据解析失败，数据非法什么的。</p>
</li>
<li>
<p>同时，不知道是不是作者大意了，cpm会读取本地packages目录下的文件来查询已有的本地模块文件，不过他默认没有新建这个文件夹，所以需要手动在cpm根目录新建packages文件夹，不然fs模块会报错说路径不存在。</p>
</li>
</ul>
<h2 id="整合lerna发布">整合lerna发布</h2>
<p>在搭建好了自己的npm仓库后，就可以开始尝试发布自己的模块了。因为我们私有的模块是基于npm的，所以记住，千万不能在配置文件中将lerna的client设置成“yarn”。</p>
<!-- more -->
<p>然后，我们可以：</p>
<pre><code>git add .
git-cz
lerna publish --registry=http://xxxx.com:7001
</code></pre>
<p>使用git-cz格式化我们的commit，然后使用lerna publish命令。lerna会帮我们将代码push到github对应的分支，同时依次将各个模块上传到私有的npm仓库中，同时还会修改每个package的版本号，然后去修改每个相互依赖package的版本号。</p>
<p>注意点:</p>
<ul>
<li>发布前记得确认命令行内的npm处于登录状态的，否则可能会因为未登录而无法上传模块，但是因为lerna会提前修改版本号，导致各个模块版本号已经增加了，但是模块没能更新上去，下次想要上传，就得手动控制版本号不要继续加一，否则就调版本了。</li>
<li>因为lerna会自己执行一些github命令，来推送代码，所以请务必关闭husk中添加的commitlint功能，除非你知道怎么去修改lerna执行时填写的commit message。</li>
<li>待续</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lerna学习（二）]]></title>
        <id>https://x956606865.github.io/conceal-name//post/lerna-xue-xi-er</id>
        <link href="https://x956606865.github.io/conceal-name//post/lerna-xue-xi-er">
        </link>
        <updated>2018-11-23T11:51:20.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="安装">安装</h2>
<p>lerna的安装类似于webpack，需要全局安装作为一个命令来使用，可以选择使用npx直接使用，不过为了方便，还是全局安装方便一些。</p>
<pre><code>yarn global add lerna</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="安装">安装</h2>
<p>lerna的安装类似于webpack，需要全局安装作为一个命令来使用，可以选择使用npx直接使用，不过为了方便，还是全局安装方便一些。</p>
<pre><code>yarn global add lerna
</code></pre>
<!-- more -->
<h2 id="初始化">初始化</h2>
<pre><code>mkdir myLerna
cd myLerna
lerna init --independent
</code></pre>
<p>lerna的初始化分为fix模式以及independent模式两种，默认是fix模式，或者叫做锁定模式，项目内所有的package共用版本号。不过我认为这种情况其实很少，大部分人应该都是使用独立模式，每个package拥有自己的版本号。</p>
<h2 id="创建package">创建package</h2>
<pre><code>cd packages
mkdir package-1
cd package-1
yarn init -y
cd ..
mkdir package-2
cd package-2
yarn init -y
</code></pre>
<p>这里要注意，如果你没有创建任何package，你是不能使用lerna add命令安装依赖包的，因为默认lerna会为每个package安装依赖。</p>
<h2 id="安装各种依赖">安装各种依赖</h2>
<p>在开发之前，肯定是需要先安装各种eslint、prettier、commit-lint等等规范化库的，我们为啥要把一堆package放到一个仓库？其中一个原因不就是为了直接复用一套规范文件么。</p>
<p>所以各种lint文件肯定是安装到项目全局的，这时如果使用lerna的安装命令:</p>
<pre><code>lerna add eslint --dev
</code></pre>
<p>就会发现一个问题，每个package都被单独安装了eslint，这明显是不合适的，既然是同一个项目，安装多次同一个模块算个什么事？</p>
<p>然后我们发现，lerna有提到如果你想只安装一次，那么可以把这些依赖写到每个package的package.json中，然后回到根目录运行:</p>
<pre><code>lerna bootstrap --hoist
</code></pre>
<p>bootstrap是learna一键为所有package安装依赖的命令，如果加上了--hoist参数，那么就是告诉lerna，把所有依赖全部安装到根目录中，然后分别在各自的文件夹中创建软连接指向对应的模块实际路径。</p>
<p>从解决问题的眼光来看，确实解决了重复安装的问题，不过所有模块都装到根目录混杂在一起，这让强迫症心里很不舒服，我们希望的其实是只有lint这些公共库提取出来，其他的他们自己的依赖放到他们自己的文件夹中。</p>
<p>在参考了<a href="https://github.com/babel/babel">Babel</a>仓库的做法后，明白了。因为node自身在查找模块的时候有向父级目录查询的操作，所以其实软连接什么的并不需要，甚至都不需要lerna，我们直接</p>
<pre><code>yarn add -D eslint
</code></pre>
<p>这样便直接将eslint安装到了根目录中，由于层级高，所以子目录都会受到lint规则的约束。同样，为此安装好husky等等基本库，完成仓库的初始化。(可以参考我的另一篇<a href="https://www.notion.so/aj0k3r/57b80f3f75b741e3a54546c20ae5e8e7">文章</a>)</p>
<h2 id="安装依赖包">安装依赖包</h2>
<p>安装依赖包有很多种方式，虽然可以进入对应的文件夹中直接使用yarn安装，不过为了项目统一，还是推荐使用lerna的命令来安装依赖</p>
<ul>
<li>
<p>给所有package安装某个第三方依赖：</p>
<pre><code>  lerna add module-A
</code></pre>
</li>
<li>
<p>给package-A安装第三方依赖：</p>
<pre><code>  lerna add module-A packages/package-A
</code></pre>
<p>ps:这里可以使用正则，比如官方举例的：</p>
<pre><code>  lerna add module-1 packages/prefix-*
</code></pre>
</li>
<li>
<p>package-A依赖package-B：</p>
<pre><code>  lerna add package-B --scope=package-A
</code></pre>
</li>
<li>
<p>所有package都依赖package-C：</p>
<pre><code>  lerna add package-C
</code></pre>
<p>PS.  lerna处理package互相依赖时采用的是软连接的模式，所以不用担心重复安装的问题。</p>
</li>
</ul>
<h2 id="快速新建package">快速新建package</h2>
<p>lerna提供了一个命令来快速新建package，避免了重复机械的操作</p>
<pre><code>    lerna create package-D --dependencie=[&quot;package-A&quot;,&quot;lodash&quot;]
</code></pre>
<p>这样可以快速新建一个package并且申明他依赖的内部package或者外部包</p>
<h2 id="值得注意的命令">值得注意的命令</h2>
<ul>
<li>
<p>lerna run xxx</p>
<p>按照官方说法，是为所有的package执行xxx这个script，听起来有点唬人，所以我测试了一下。</p>
<p>首先，这里的命令，不是指根目录的package.json里面的script，lerna根本不会去管根目录里面的script。</p>
<p>当你运行 lerna run xxx时，他会依次遍历每个package目录的package.json，如果有同名的script就执行，没有的就跳过，每个目录对应的xxx script执行的内容也可以完全不一样，互不干扰。</p>
</li>
<li>
<p>lerna exec — xxx</p>
<p>与run命令对应的另一个命令就是exec命令，不过不同的是exec命令接受的是bash命令而不是script名称，他会为每个package执行对应的bash操作，不会跳过</p>
</li>
</ul>
<p>第二篇结束......</p>
<p>参考链接:</p>
<ul>
<li><a href="https://codeburst.io/monorepos-by-example-part-1-3a883b49047e">Monorepos By Example: Part 1</a></li>
<li><a href="https://codeburst.io/monorepos-by-example-part-2-4153712cfa31">Monorepos By Example: Part 2</a></li>
<li><a href="https://codeburst.io/monorepos-by-example-part-3-1ebdea7ccbea">Monorepos By Example: Part 3</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lerna 学习（一）思路篇]]></title>
        <id>https://x956606865.github.io/conceal-name//post/lerna-xue-xi-yi-si-lu-pian</id>
        <link href="https://x956606865.github.io/conceal-name//post/lerna-xue-xi-yi-si-lu-pian">
        </link>
        <updated>2018-11-22T11:47:59.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="lerna是啥">Lerna是啥?</h2>
<blockquote>
<p>Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="lerna是啥">Lerna是啥?</h2>
<blockquote>
<p>Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.</p>
</blockquote>
<!-- more -->
<p>这是来自lerna的github仓库的自我描述。大致意思就是他是一个用来管理multi-package项目的工具，通过使用git和npm（其实yarn也是支持的）</p>
<h2 id="multi-repo以及mono-repo">multi-repo以及mono-repo</h2>
<p>lerna是标准的mono-repo的工具，与普遍的multi-repo的组织架构有着显著的区别。</p>
<p>传统开发即是multi-repo的，即一个module一个仓库，比如公司内部提炼的常用工具、常用组件都是分开存放，开发的时候install在同一个项目里。</p>
<p>而mono-repo则是一个仓库包含整个项目的所有，分成多个package目录分开管理，统一处理相互依赖。比如Babel、react、angular等等知名的库都是采用了mono-repo的方式。比如babel，babel-cli、babel-core、babel-node等等工具都是放在了同一个仓库“babel”中的，而我们安装的时候实际上是yarn add @babel/babel-core这样的安装方式。这就是很典型的mono-repo的模式，整个babel的产品都内聚到了babel的整个仓库内。</p>
<h2 id="mono-repo的优点">mono-repo的优点</h2>
<ul>
<li>项目规范可以更轻松的整合;</li>
<li>模块间依赖稳定，统一更新，避免了开发人员相互间使用对方模块时版本更新不一致导致的bug;</li>
<li>可以更高效的复用模块，加快开发效率;</li>
<li>各模块间相互依赖，开发又相对独立，避免对于特定项目的过强的耦合;</li>
<li>统一整合各个模块单独的更新生成一个CHANGELOG;</li>
<li>唯一的仓库，避免用户issue的分散，以及issue的scope的不明确。</li>
</ul>
<h2 id="mono-repo的缺点">mono-repo的缺点：</h2>
<ul>
<li>仓库体积会非常的大;</li>
<li>统一CHANGELOG也会混入一些和整体项目无关的模块更新。</li>
</ul>
<h2 id="是否值得使用">是否值得使用？</h2>
<p>对于新知识来说，最重要的一点就是是否值得使用？什么时候应该用？适合哪些情况？</p>
<p>首先，作为一个外包型产品公司的码农，我认为对新项目使用mono-repo是不值得的。或者说一开始学习的时候，我就一直以公司产品的角度来看待mono-repo，想了好久都不明白这么做的意义在哪里？公共组件如果在同一个项目中，那么新项目怎么办？是copy过去？还是干脆一个仓库把后续的新项目都包括了？</p>
<p>这显然是不合适的，而且把原有的问题变得更复杂了。主要在与一个冲突：外包型的公司产品是互不关联的，他们没有任何内聚在一起的理由。同时，公司自己提炼的组件、工具等，其实和做的产品也是没有内聚的理由的。新项目依赖公司提炼的东西，但是他们之间只是开发上的依赖而不是内在的概念性依赖。就好像babel-core和babel-compile这是概念性的强联系，即使他们并不一定直接依赖。但是我们的项目依赖了babel-core,这就是一种仅仅在开发上的依赖。</p>
<p>那么是否可以使用mono-repo呢？当然是可以的，作为公司本身，我们的公共组件、工具等等等等是完全内聚的，完全可以合并成一个mono-repo，然后新项目来依赖这个repo这是完全可以的。好处也是有的，工具自己的内部依赖随时都是一致的，可以保证了整个repo的稳定性。但是好处并不明显，不管是lerna宣传的版本号统一还是自动处理多package生成统一的changelog，这对于外包型项目都没有显著的好处。</p>
<blockquote>
<p>所以，对于大多数外包型的项目，mono-repo都没有足够的好处，意义不大</p>
</blockquote>
<p>其次，对于来源项目开发者来说，对大多数个人开发者来说也是不太适合的。因为个人项目大多数体积偏小、功能比较单一，可以说没有拆分的意义。毕竟不是每个人都能像尤雨奚大佬一样一个人维护一个超大的项目的(&gt;﹏&lt;)。</p>
<blockquote>
<p>所以，mono-repo更适合那些大型开源项目，本身复杂性较高，多人维护需要保证相互间版本一致，同时功能复杂，大多数可以独立成单独的项目维护的开源项目</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目规范化开发探索]]></title>
        <id>https://x956606865.github.io/conceal-name//post/xiang-mu-gui-fan-hua-kai-fa-tan-suo</id>
        <link href="https://x956606865.github.io/conceal-name//post/xiang-mu-gui-fan-hua-kai-fa-tan-suo">
        </link>
        <updated>2018-11-12T11:38:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前因">前因</h2>
<p>这次在fcc2018前端大会上，听到了余澈前辈的《开源项目维护》分享，深有收获.所以站在前人的肩膀上探索探索</p>
<h2 id="痛点">痛点</h2>
<p>现在前端项目开发，主要是由代码、依赖库、文档、changelog、测试文件等等几部分组成。但是由于前端开发的不规范，大部分创业公司开发都是不考虑文档以及changelog之类的部分的，只要代码跑通，就OK。同样的，注释什么的自然也是不会去写的，整个项目就显得十分的杂乱，后来人也难以接手。</p>
<h2 id="思路">思路</h2>
<p>其实文档、changelog之类的内容都具有一定的可预见性，遵循于一定的原则，由此可见，理论上是可以由代码来自动实现的。因此，主要的自动化处理方式便是使用jsdoc注释规则规范化注释，由此可以借助jsdoc之类的工具自动生成文档。其次，使用统一的eslint文件规范代码的风格，使用统一的prettier配置文件规范代码的样式，然后使用统一的commitlint文件规范并自动生成commit message，有了规范的commit message后，就可以使用工具提取相应的内容，自动生成changelog。由此而来，项目最繁琐的几个痛点便可以轻松简化到规范的注释以及规范的commit message两点，即可。</p>
<h2 id="husky">Husky</h2>
<p>自动规范化项目，最核心的一个工具便是husky，简单来说，husky提供了几个钩子，可以拦截到git的比如commit、push等等操作，然后在操作前，执行某些脚本，预处理被操作的对象。</p>
<ul>
<li>
<p>安装</p>
<pre><code>  npm install husky --save-dev
</code></pre>
</li>
<li>
<p>配置</p>
<p>在最新版中，hasky的配置不需要写在npm script中了，直接在package.json中添加一下字段即可。</p>
<pre><code>      {
      &quot;husky&quot;: {
          &quot;hooks&quot;: {
          &quot;pre-commit&quot;: &quot;npm run test&quot;,
          &quot;pre-push&quot;: &quot;npm run test&quot;,
          &quot;...&quot;: &quot;...&quot;
          }
      }
      }
</code></pre>
</li>
</ul>
<h2 id="lint-staged">Lint-staged</h2>
<p>Lint-staged是自动规范化项目第二重要的工具，主要功能为依次运行传入的命令数组，但是，约束命令的作用范围只会影响到git staged范围内的文件，即用git add 添加到待commit队列的文件，从而避免影响到其他文件，同时也能加快预处理脚本的速度。</p>
<ul>
<li>
<p>安装</p>
<pre><code>  npm install --save-dev lint-staged
</code></pre>
</li>
<li>
<p>配置</p>
<p>同样是直接在package.json文件中直接添加lint-staged的命令列表</p>
<pre><code>      &quot;lint-staged&quot;: {
      &quot;*.js&quot;: [&quot;eslint --fix&quot;, &quot;git add&quot;]
      }
</code></pre>
<p>然后，将lint-staged与husky整合:</p>
<pre><code>      &quot;husky&quot;: {
      &quot;hooks&quot;: {  
          &quot;pre-commit&quot;: &quot;lint-staged&quot;
      }
      }
</code></pre>
<p>这样，便做到了每次commit的时候自动eslint将要上传的文件，然后才commit，其他没有被add的文件不会被eslint处理。</p>
</li>
</ul>
<h2 id="prettier">Prettier</h2>
<p>有了以上条件后，我们便可以来添加我们的第一个预处理脚本Prettier。prettier是最出名的代码格式化工具之一。由于我们每个人的编程习惯不一样，有的人喜欢分号，有些人不喜欢分号，有些人四个空格缩进，有些人八个空格缩进。如果强制每个人编码习惯一样，总是让人比较难受，所以这里可以约定一个统一个代码风格配置文件，在提交的时候自动处理代码，将它们格式化为统一的风格，这样每个人写代码的时候可以按着自己的习惯写，最后提交的代码又是风格一致的，两全其美。</p>
<ul>
<li>
<p>安装</p>
<pre><code>  yarn global add prettier
</code></pre>
</li>
<li>
<p>配置</p>
</li>
</ul>
<p><a href="https://prettier.io/docs/en/configuration.html">https://prettier.io/docs/en/configuration.html</a></p>
<ul>
<li>
<p>整合到lint-staged</p>
<pre><code>  &quot;*.js&quot;: [
      &quot;prettier --config ./.prettierrc --write&quot;,
      &quot;git add&quot;
    ]
</code></pre>
</li>
</ul>
<h2 id="commit-message-规范">Commit-message 规范</h2>
<p>要从commit message中提取到有用的数据用来生成CHANGELOG，那么commit message就必须有一个相对固定的格式，同时这个格式能够基本覆盖到所有的comm操作类型。</p>
<p>目前比较流行的格式为<a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">Angular Git Commit Guidelines</a></p>
<p>大致的格式如下:</p>
<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;BLANK LINE&gt;
&lt;body&gt;
&lt;BLANK LINE&gt;
&lt;footer&gt;
</code></pre>
<ul>
<li>&lt;type&gt;:本次commit的类型，比如新特性feat，bug修复fix等等</li>
<li>&lt;scope&gt;:本次操作波及的范围，可自定义</li>
<li>&lt;BLANK LINE&gt;:空行</li>
<li>&lt;body&gt;:可选，描述本次commit的动机等等，如需换行，在行尾添加&quot;|&quot;</li>
<li>&lt;footer&gt;:可选，描述如解决了某个issue，或者这次为breaking change，对应的upgrade的方法等等</li>
</ul>
<h2 id="commitizen">Commitizen</h2>
<p>由上可见，一个规范的commit message其实十分的麻烦，对于一个连注释都不写的公司来说，要求同事都这样规范的写commit message显然是不可能的。所以，我们需要工具，能够自动生成这样格式的commit message，所以有了工具commitizen。</p>
<ul>
<li>
<p>安装</p>
<pre><code>  npm install -g commitizen
</code></pre>
</li>
</ul>
<p>安装完成后，系统便会多出git cz命令，git cz能够完全的代替git commit命令，拥有其所有的参数，使用方法完全一样，同时也可以被husky所拦截到.</p>
<p>commitizen采用了询问的方式来获取对应的commit信息，大致页面如下:</p>
<p><a href="https://www.notion.so/57b80f3f75b741e3a54546c20ae5e8e7#740da08879544516a6e90da754cb9b4a"></a></p>
<h2 id="cz-conventional-changelog">cz-conventional-changelog</h2>
<p>有了格式化的commit message后，我们便可以用来自动生成changelog了，好在Commitizen有着配套的工具。</p>
<pre><code>commitizen init cz-conventional-changelog --save-dev --save-exact
</code></pre>
<p>使用commitizen初始化cz-conventional-changelog，他会作为一个adapter来解析对应的内容。由于commit message的规范其实有很多种，angular的规范只是很常用的规范之一，所以对于不同的规范需要不同的adapter才能解析出对应的数据，不过因为和commitizen整合，所以不需要考虑格式和adapter不匹配的问题，毕竟格式是有commitizen自动生成的。</p>
<h2 id="commitlint">Commitlint</h2>
<p>虽然有了自动生成工具，但是肯定还是有偷懒的小伙伴懒得去写，直接随便写个message就上传，这样的话就会破坏掉原有的格式（强迫症也会表示很难受啊喂），所以我们需要一个lint工具来替我们检测对应的commit message是不是一个合法的commit message。当然，这个工具也应该自动调用，在上传的时候自动检测。</p>
<ul>
<li>
<p>安装</p>
<pre><code>  npm install --save-dev @commitlint/config-conventional @commitlint/cli
</code></pre>
<p>安装conventional格式的lint以及对应的cli（commitlint也有其他格式的adapter，若使用的是其他规范，请参考<a href="https://github.com/marionebl/commitlint">官网</a>）</p>
</li>
<li>
<p>配置</p>
<pre><code>  echo &quot;module.exports = {extends: ['@commitlint/config-conventional']}&quot; &gt; commitlint.config.js
</code></pre>
<p>你要是不嫌麻烦，新建对应的文件，然后把内容拷进去效果也一样。</p>
</li>
<li>
<p>与husky整合</p>
<pre><code>  {
    &quot;husky&quot;: {
      &quot;hooks&quot;: {
        &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;
      }  
    }
  }
</code></pre>
<p>这样便可以做到在commit的时候自动检测commit message是否合法了</p>
</li>
</ul>
<h2 id="standard-version">standard-version</h2>
<p>有了对应的adapter，就可以提取commit-message的信息，从而生成changelog。我们可以使用Conventional Changelog来生成changelog，不过Conventional Changelog是生成changelog的基本库，它们更推荐使用基于它们来实现的库standard-version来进行CHANGELOG的生成：</p>
<p><a href="https://www.notion.so/57b80f3f75b741e3a54546c20ae5e8e7#5a6f6095097d46bdb2a2d63df422ed6d"></a></p>
<ul>
<li>
<p>安装</p>
<pre><code>  npm i --save-dev standard-version
</code></pre>
</li>
<li>
<p>在package中使用npm script整合standard-version</p>
<pre><code>  {
    &quot;scripts&quot;: {
      &quot;release&quot;: &quot;standard-version&quot;
    }
  }
</code></pre>
</li>
</ul>
<p>这样，我们每次到了需要发布一个新版本的时候，使用npm run release就可以生成上一个版本到现在的CHANGELOG，同时standard-version本身也可以用作项目的版本管理工具。</p>
<h2 id="jsdoc">JSDOC</h2>
<p>jsdoc是一个通过注释自动生成文档的工具，虽然jsdoc已经很久没有人维护了，很多新语法都不支持（连PR都没人去通过了，感觉凉凉了），不过jsdoc的注释语法却是注释生成文档的通用语法，而且和vscode等编辑器整合的非常好，简单的snippet便可以生成对应的注释，如果再加上document-this插件，就基本OK了，写注释十分轻松。不过现在注释生成文档的工具，要么很丑，要么就是很久没维护了，就很蛋疼emmmm，只能说将就着用一用。。。。</p>
<p>待续。。。。。</p>
<p>Link: <a href="https://www.notion.so/aj0k3r/57b80f3f75b741e3a54546c20ae5e8e7"></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ECMA 提案-'decorator' 研究]]></title>
        <id>https://x956606865.github.io/conceal-name//post/ecma-ti-an-decorator-yan-jiu</id>
        <link href="https://x956606865.github.io/conceal-name//post/ecma-ti-an-decorator-yan-jiu">
        </link>
        <updated>2018-11-04T11:32:24.000Z</updated>
        <summary type="html"><![CDATA[<p>//ps:根据大佬的解释，现在提案修改，不推荐使用legacy这种模式了，新版模式待研究后再更新Orz</p>
]]></summary>
        <content type="html"><![CDATA[<p>//ps:根据大佬的解释，现在提案修改，不推荐使用legacy这种模式了，新版模式待研究后再更新Orz</p>
<!-- more -->
<h2 id="提案状态stage-2">提案状态：Stage-2</h2>
<h2 id="链接httpstc39githubioproposal-decorators">链接:<a href="https://tc39.github.io/proposal-decorators/"><em>https://tc39.github.io/proposal-decorators/</em></a></h2>
<h2 id="需求-babel-7">需求: Babel-7</h2>
<h2 id="插件babelplugin-proposal-decorators">插件:@babel/plugin-proposal-decorators</h2>
<pre><code>          (ps:babel7以后插件名称全部有所改动)
</code></pre>
<h2 id="快速安装">快速安装：</h2>
<pre><code>    yarn global add @babel/cli
    yarn global add @babel/node
    yarn add @babel/plugin-proposal-decorators
</code></pre>
<p>使用babel-node、babel-cli这样的名称只能安装到6版本的babel工具，7版本的工具全部改由@babel前缀</p>
<p>新建.babelrc文件:</p>
<pre><code>    {
        &quot;plugins&quot;:[
    				[&quot;@babel/plugin-proposal-pipeline-operator&quot;, { &quot;proposal&quot;: &quot;minimal&quot; }],
    				[&quot;@babel/plugin-proposal-decorators&quot;,{&quot;legacy&quot;:true}]]
    }
</code></pre>
<p>新建index.js文件:</p>
<pre><code>    function testable(isTestable) {
        return function(target) {
            target.isTestable = isTestable;
        }
    }
    
    @testable(true)
    class MyTestableClass {}
    console.log(MyTestableClass.isTestable)// true
     
    
    @testable(false)
    class MyClass {}
    console.log(MyClass.isTestable)// false
</code></pre>
<p>然后执行:</p>
<pre><code>babel-node index.js
</code></pre>
<p>即可看到对应的输出结果。</p>
<h2 id="思考">思考:</h2>
<ul>
<li>
<p>装饰器语法本身只是单纯的用一个函数去处理一个类，大多数时候都是对其prototype的修改，用es5也能实现对应的功能，但是使用装饰器能使代码更加简洁，结构更加清晰。</p>
</li>
<li>
<p>虽然在js中，class和function不存在本质上的区别，只是一个语法糖的存在，但是由于函数的作用域提升的问题，如果函数中有自由变量的使用，就会出现不可预期的一些bug。</p>
<p>例如如下代码:(案例来自阮一峰es6教程)</p>
</li>
</ul>
<pre><code>    var counter = 0;
    
    var add = function () {
      counter++;
    };
    
    @add
    function foo() {
    }
</code></pre>
<p>在实际编译后，会变成如下：</p>
<pre><code>    @add
    function foo() {
    }
    
    var counter;
    var add;
    
    counter = 0;
    
    add = function () {
      counter++;
    };
</code></pre>
<p>从而导致程序出粗。</p>
<ul>
<li>由于装饰器可以优雅的修改prototype，猜想可以优雅的尝试AOP编程，例如:</li>
</ul>
<pre><code>    function AOP(options) {
        const {beforeFunc,afterFunc}=Object.assign({
            beforeFunc:()=&gt;{},
            afterFunc:()=&gt;{}
        },options)
        return function(target, key, descriptor) {
            const oldTarget = descriptor.value
            descriptor.value=function(){
                beforeFunc.apply(this,arguments)
                const value=oldTarget.apply(this,arguments)
                afterFunc.apply(this.arguments)
                return value
            }
            return descriptor
        }
    }
    function logBefore(){
        console.log(&quot;before&quot;)
    }
    function logAfter(){
        console.log(&quot;after&quot;)
    }
    class MyClass {
        @AOP({
            beforeFunc:logBefore,
            afterFunc:logAfter
        })
        func(){
            console.log(&quot;run&quot;)
        }
    }
    const obj=new MyClass()
    obj.func()
</code></pre>
<p>这样每次就简单清晰的注入了before和after两个函数，在这两个函数中可以做数据预处理、数据状态监测等等一系列的功能，包括GA数据的监测也可以这样放入。这样和JAVA的AOP思路就十分的接近了。</p>
<ul>
<li>同样由于可以处理proptype，理论上可以实现类的依赖注入，传入依赖的字符串数组，然后解析出是npm模块还是本地文件，然后使用inline require动态加载对应的库，注入到类中。同样可以注入的还可以有项目的config的配置变量等等。</li>
<li>待续</li>
</ul>
]]></content>
    </entry>
</feed>